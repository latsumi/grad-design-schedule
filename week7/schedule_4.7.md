### 今日目标

第三章实验指导书阅读记录，第三章代码跑通

### 今日碎碎念

本来熬夜的，结果零零碎碎睡了差不多六个多小时，算了，好好利用这个上午吧。加紧看c语言版本的指导书，赶紧对比下代码。

### 流水账

现在是半夜十二点，第三章指导书才起了个头，一小时之内能看完吗？做ppt至少也得1-2小时吧。
草，怎么就三点了，第三章才看了一半。赶紧结束吧，多看看解析，少在意代码细节。

### 实验指导书chap3 c语言版本

上一章完成了任务的连续执行。这部分主要完成任务的协作和抢占式调度。

我们什么时候实现的页表？？

`proc`文件 进程的定义和初始化

batch里面给每个app分配了一个进程控制块

`idle` 进程是第一个进程(boot进程)，也是唯一一个永远会存在的进程，它还有一个大家更熟悉的面孔，它就是 os 的 main 函数

yield函数是干啥的？

### 实验指导书chap3 rust版本

> 跟实验2的关系

而计算机硬件在快速发展，内存容量在逐渐增大，处理器的速度也在增加，外设IO性能方面的进展不大。这就使得以往内存只能放下一个程序的情况得到很大改善，但处理器的空闲程度加大了。于是科学家就开始考虑在内存中尽量同时驻留多个应用，这样处理器的利用率就会提高。但只有一个程序执行完毕后或主动放弃执行，处理器才能执行另外一个程序。这种运行方式称为 多道程序。

让应用在执行IO操作时，可以主动 释放处理器，称为协作式

支持 分时多任务 的抢占式操作系统

由于只有一个 处理器，即使这样做，同一时间最多还是只能运行一个应用，还浪费了更多的内存来把所有 的应用都加载进来。那么这样做有什么意义呢？

终于明白ch3-coop是什么意思了，就是协作式的分支

生成link_app.S时，pack程序依次将每个app的bin文件（即代码）塞在文件中的data段（此时是在文件里）。

batch文件中的load_app函数根据 base_address 依次加一个固定的max大小然后加载程序到内存

第一章：函数调用时的栈的切换；第二章：特权级切换时trap负责保存上下文；第三章：应用程序的切换。

批处理系统自动连续完成应用的加载和运行

通常外设会提供一个可读的寄存器记录它目前的工作状态，于是 CPU 需要不断原地循环读取它直到它的结果显示设备已经将请求处理完毕了，才能向下执行。然而，外设的计算速度和 CPU 相比可能慢了几个数量级。我们可以先进行任务切换去执行其他应用，只要同时存在的应用足够多，就能保证 CPU 不必浪费时间在等待外设上

### 今日总结

到凌晨三点才读完指导书，虽然做事总会超出预期的时间，还是朝着准时完成的目标努力吧!
