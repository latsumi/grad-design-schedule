### 今日目标

尝试先看看xv6开始做了什么，看看开头的部分有没有可参考的。再新建一个c项目进行实际的测试操作

### 可能的学习内容

看吴一凡的gitbook

看下xv6的完成轨迹

### 需要完成的工作


### 一日流水账

10:00 - 11:00 看Xv6 for riscv

11:00 - 看 `MIT6.S081` 课程的中文翻译，感觉值得仔细研究记录

15:00 - 17:00 继续看`MIT6.S081` 大概挑目前有用的看完了，对知识体系很有用的知识，但是好像没办法直接帮我做好现在的工程。因为它并不是从零开始的，我还不知道到目前所需的功能需要自己实现到什么程度。

20:00 - 实践发现riscv64-unknown-elf-gcc编译链接后的可执行文件可以直接用qemu-riscv64运行出正确结果，和设想的不太一样，为什么可以直接调用printf函数？那么如何移除对标准库的依赖呢？找到了 `openSBI` ，似乎是这部分相当关键的一个东西。

23:00 找到了个非常详细地介绍riscv裸机编程的博客，而且是用c实现的，美妙！这应该是明天最主要的目标了。

### MIT6.S081笔记

0，1文件描述符风格，文件读写中

对于那些想要运行程序，但是还希望能拿回控制权的场景，可以先执行fork系统调用，然后在子进程中调用exec。因为调用exec后将无法返回原进程

Xv6：有三大块代码，kernel（编译成一个叫kernel的二进制文件，并运行在内核态），user（运行在用户态），mkfs（创建一个空的文件镜像，将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统 暂时不太理解）

QEMU的主循环中，只在做一件事情：读取4字节或者8字节的RISC-V指令 -> 解析RISC-V指令，并找出对应的操作码（op code） -> 在软件中执行相应的指令

QEMU第一个指令地址 `0x80000000`

risc和cisc：
```
首先是指令的数量。实际上，创造RISC-V的一个非常大的初衷就是因为Intel手册中指令数量太多了。x86-64指令介绍由3个文档组成，并且新的指令以每个月3条的速度在增加。因为x86-64是在1970年代发布的，所以我认为现在有多于15000条指令。RISC-V指令介绍由两个文档组成。在这节课中，不需要你们记住每一个RISC-V指令，但是如果你感兴趣或者你发现你不能理解某个具体的指令的话，在课程网站的参考页面有RISC-V指令的两个文档链接。这两个文档包含了RISC-V的指令集的所有信息，分别是240页和135页，相比x86的指令集文档要小得多的多。这是有关RISC-V比较好的一个方面。所以在RISC-V中，我们有更少的指令数量。除此之外，RISC-V指令也更加简单。在x86-64中，很多指令都做了不止一件事情。这些指令中的每一条都执行了一系列复杂的操作并返回结果。但是RISC-V不会这样做，RISC-V的指令趋向于完成更简单的工作，相应的也消耗更少的CPU执行时间。这其实是设计人员的在底层设计时的取舍。并没有一些非常确定的原因说RISC比CISC更好。它们各自有各自的使用场景。相比x86来说，RISC另一件有意思的事情是它是开源的。这是市场上唯一的一款开源指令集，这意味着任何人都可以为RISC-V开发主板。RISC-V是来自于UC-Berkly的一个研究项目，之后被大量的公司选中并做了支持，网上有这些公司的名单，许多大公司对于支持一个开源指令集都感兴趣。
```

5.3 gdb调试的示例

用户空间和内核空间的切换通常被称为trap

6.1 介绍了riscv的寄存器和作用

### 零散的可能用到的知识


### 今日总结

今天仍然没有什么工程上的进展，学了很多os方面的知识，花了很多时间去对比几个版本的rCore文档，试图找到可以直接参考的细节，但是仍然不知道如何移除对系统的依赖（编译时候加上参数 `-nostdlib`？）。

明天的首要目标应该是先读完 [这个博客](https://github.com/riscv/riscv-sbi-doc/blob/master/riscv-sbi.adoc#38-function-listing)，里面有详细介绍了裸机编程实践的过程。